## 6.4 封装例程

&emsp;&emsp;上一节讲述了图6.1中当一个系统调用陷入内核时的系统调用处理程序和服务例程。那么libc库中是如何对不同的服务例程进行封装？
Linux的系统调用有200多个，相应的服务例程也这么多，显然，对其一一进行封装是麻烦而不现实的。于是，为了简化对相应的封装例程的声明，Linux定义了从_syscall0到_syscall5的六个宏。之所以定义六个宏，是因为系统调用的参数个数一般不超过六个。

&emsp;&emsp;每个宏名字的数字0到5对应着系统调用所用的参数个数(系统调用号除外)。显然，不能用这些宏来为超过5个参数的系统调用或产生非标准返回值的系统调用定义封装例程。

&emsp;&emsp;每个宏严格地需要2+2×n个参数，n是系统调用的参数个数。另外两个参数指明系统调用的返回值类型和名字；每一对参数指明相应的系统调用参数的类型和名字。因此，像fork()系统调用的封装例程可以通过如下语句产生：
```c
_syscall0(int，fork)
```
&emsp;&emsp;而write()的封装例程可以通过如下语句生产：
```c
_syscall3(int，write，int，fd，const char *，buf，unsigned int，count)
```
&emsp;&emsp;可以把_syscall3（）这个宏展开成如下的汇编语言代码:
```c
write:

pushl %ebx ; 将ebx 压入栈

movl 8(%esp)， %ebx ;
将一个参数放入ebx（栈中前两个位置存放的是类型和名字，占8个字节）

movl 12(%esp)， %ecx ; 将第二个参数放入ecx

movl 16(%esp)， %edx ; 将第三个参数放入edx

movl $4， %eax ; 把系统调用名对应的系统调用号放入 eax

int $0x80 ; 进行系统调用

cmpl $-126， %eax ; 检查返回码

jbe .L1 ; 如无错跳转

negl %eax ; 求eax的补码

movl %eax， errno ; 将所求的结果放入 errno变量

movl $-1， %eax ; 将eax 置为-1

.L1: popl %ebx ; 从栈中弹出ebx

ret ;返回到调用程序
```
&emsp;&emsp;注意write（）函数的参数是如何在执行0x80指令前被装入到CPU寄存器中。如果eax中的返回值在-1和-125之间，必须被解释为错误码(内核假定在include/asm-i386/errno.h中定义的最大错误码为125)。如果是这种情况，封装例程在errno中存放-eax的值并返回值-1；否则，返回eax中的值。

&emsp;&emsp;通过这种封装，在用户态下调用系统调用就变得简单多了，用户既不需要关心系统调用号，也不需要提供复杂的参数，而且还在不知不觉中让内核为自己提供了服务。这里要说明的是，虽然系统调用一般用在用户程序中，但在内核中同样可以调用这种封装了的系统调用。只不过二者有一些区别而已：

1.  在用户态进行系统调用时，转换到内核态的系统调用处理程序时要进行用户态堆栈到内核态堆栈的切换，即从“int0x80”指令转换到内核态的“system_call”函数时，要保存寄存器ss、esp；而当“iret”指令从“system_call”返回用户态时要取回ss、esp的值。

2.  在内核中进行系统调用时，不用进行堆栈切换，即“int0x80”指令不用切换到内核态“system_call”函数，也不必保存寄存器ss、esp；而当“iret”指令从“system_call”返回，仍然是内核态，所以也不用取回ss、esp的值。

