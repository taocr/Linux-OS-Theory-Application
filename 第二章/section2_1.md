## **2.1&emsp;内存寻址**

&emsp;&emsp;曾经有一个叫“阿兰.图灵”的天才1，它设想出了一种简单但运算能力几乎无限发达的理想机器，这不是一个具体的机械设备，而是一个思想模型，可以用来计算能想象得到的所有可计算函数。这个有趣的机器由一个控制器，一个读写头和一条假设两端无限长的带子组成。工作带相当于存储器，被划分成大小相同的格子，每格上可写一个字母，读写头可以在工作带上随意移动，而控制器可以要求读写头读取其下方工作带上的字母。

&emsp;&emsp;这听起来仅仅是纸上谈兵，但它却是当代冯.诺依曼计算机体系的理论鼻祖。它带来的“数据连续存储和选择读取思想”是目前我们使用的几乎所有机器运行背后的灵魂。计算机体系结构中的核心问题之一就是如何有效地进行内存寻址，因为所有运算的前提都是先要从内存中取得数据，所以内存寻址技术从某种程度上代表了计算机技术。
&emsp;&emsp;据说他16岁开始研究相对论，虽然英年早逝，但才气纵横逻辑学、物理学、数学等多个领域，尤其是数学逻辑上的所作所为奠定了现代计算技术的理论基础 。后来以他名字命名的“图灵奖”被看作计算机学界的最高荣誉。

### **2.1.1 &emsp;Intel X86 CPU寻址的演变**

&emsp;&emsp;在微处理器的历史上，第一款微处理器芯片4004是由Intel推出的，那是一个4位的微处理器。在4004之后，intel推出了一款8位处理器8080，它有1个主累加器（寄存器A）和6个次累加器（寄存器B,C,D,E,H和L）,几个次累加器可以配对（如组成BC, DE或HL）用来访问16位的内存地址，也就是说8080可访问到64K内的地址空间。另外，那时还没有段的概念，访问内存都要通过绝对地址，因此程序中的地址必须进行硬编码（给出具体地址），而且也难以重定位，这就不难理解为什么当时的软件大都是些可控性弱,结构简陋，数据处理量小的工控程序了。

&emsp;&emsp;几年后，intel开发出了16位的处理器8086，这个处理器标志着Intel X86王朝的开始，这也是内存寻址的第一次飞跃。之所以说这是一次飞跃，是因为8086处理器引入了一个重要概念—段

&emsp;&emsp;8086处理器的寻址目标是1M大的内存空间，于是它的地址总线扩展到了20位。但是，一个问题摆在了Intel设计人员面前，虽然地址总线宽度是20位的，但是CPU中“算术逻辑运算单元（ALU）”的宽度，即数据总线却只有16位，也就是可直接加以运算的指针长度是16位的。如何填补这个空隙呢？可能的解决方案有多种，例如，可以像一些8位CPU中那样，增设一些20位的指令专用于地址运算和操作，但是那样又会造成CPU内存结构的不均匀。又例如，当时的PDP－11小型机也是16位的，但是其内存管理单元（MMU）可以将16位的地址映射到24位的地址空间。受此启发，Intel设计了一种在当时看来不失为巧妙的方法，即分段的方法。 在微处理器的历史上，第一款微处理器芯片4004是由Intel推出的，那是一个4位的微处理器。在4004之后，intel推出了一款8位处理器8080，它有1个主累加器（寄存器A）和6个次累加器（寄存器B,C,D,E,H和L）,几个次累加器可以配对（如组成BC, DE或HL）用来访问16位的内存地址，也就是说8080可访问到64K内的地址空间。另外，那时还没有段的概念，访问内存都要通过绝对地址，因此程序中的地址必须进行硬编码（给出具体地址），而且也难以重定位，这就不难理解为什么当时的软件大都是些可控性弱,结构简陋，数据处理量小的工控程序了。

&emsp;&emsp;几年后，intel开发出了16位的处理器8086，这个处理器标志着Intel X86王朝的开始，这也是内存寻址的第一次飞跃。之所以说这是一次飞跃，是因为8086处理器引入了一个重要概念—段

&emsp;&emsp;为了支持分段，Intel在8086 CPU中设置了四个段寄存器：CS、DS、SS和ES，分别用于可执行代码段、数据段、堆栈段及其他段。每个段寄存器都是16位的，对应于地址总线中的高16位。每条“访内”指令中的内部地址也都是16位的，但是在送上地址总线之前，CPU内部自动地把它与某个段寄存器中的内容相加。因为段寄存器中的内容对应于20位地址总线中的高16位(也就是把段寄存器左移4位)，所以相加时实际上是内存总线中的高12位与段寄存器中的16位相加，而低4位保留不变，这样就形成一个20位的实际地址，也就实现了从16位内存地址到20位实际地址的转换，或者叫**“映射”**。

&emsp;&emsp;段式内存管理带来了显而易见的优势，程序的地址不再需要硬编码了，调试错误也更容易定位了，更可贵的是支持更大的内存地址。程序员开始获得了自由。

&emsp;&emsp;技术的发展不会就此止步。intel的80286处理器于1982年问世了，它的地址总线位数增加到了24位，因此可以访问到16M的内存空间。更重要的是从此开始引进了一个全新理念—**保护模式**。这种模式下内存段的访问受到了限制。访问内存时不能直接从段寄存器中获得段的起始地址了，而需要经过额外转换和检查（从此你不能再随意存取数据段,具体保护和实现我们后面讲述）。

&emsp;&emsp;为了和过去兼容，80286内存寻址可以有两种方式，一种是先进的保护模式，另一种是老式的8086方式，被成为**实模式**。系统启动时处理器处于实模式，只能访问1M空间，经过处理可进入保护模式，访问空间扩大到16M，但是要想从保护模式返回到实模式，你只有重新启动机器。还有一个致命的缺陷是80286虽然扩大了访问空间，但是每个段的大小还是64k，程序规模仍受到限制。因此这个先天低能儿注定命不会很久。很快它就被天资卓越的兄弟——80386代替了。

&emsp;&emsp;80386是一个32位的CPU，也就是它的ALU数据总线是32位的，同时它的地址总线与数据总线宽度一致，也是32位，因此，其寻址能力达到4GB。对于内存来说，似乎是足够了。从理论上说，当数据总线与地址总线宽度一致时，其CPU结构应该简洁明了。但是，80386无法做到这一点。作为X86产品系列的一员，80386必须维持那些段寄存器的存在，还必须支持实模式，同时又要能支持保护模式，这给Intel的设计人员带来很大的挑战。

&emsp;&emsp;Intel选择了在段寄存器的基础上构筑保护模式，并且保留段寄存器16位。在保护模式下,它的段范围不再受限于64K，可以达到4G（参见段机制一节）。这一下真正解放了软件工程师,他们不必再费尽心思去压缩程序规模，软件功能也因此迅速提升。

&emsp;&emsp;从8086的16位到80386的32位处理器，这看起来是处理器位数的变化，但实质上是处理器体系结构的变化，从寻址方式上说，就是从“实模式”到“保护模式”的变化。从80386以后，Intel的CPU经历了80486、Pentium、PentiumII、PentiumIII等型号，虽然它们在速度上提高了好几个数量级，功能上也有不少改进，但基本上属于同一种系统结构的改进与加强，而无本质的变化，所以我们把80386以后的处理器统称为**80x86**。

### **2.1.2    &emsp; 80X86寄存器简介**

&emsp;&emsp;80386作为80X86系列中的一员，必须保证向后兼容，也就是说，既要支持16位的处理器，也要支持32位的处理器。在8086中，所有的寄存器都是16位的，我们来看一下80x86中寄存器有何变化：



- 	把16位的通用寄存器、标志寄存器以及指令指针寄存器扩充为32位的寄存器

- 	段寄存器仍然为16位。

- 	增加4个32位的控制寄存器

- 	增加4个系统地址寄存器

- 	增加8个调式寄存器

- 	增加2个测试寄存器

&emsp;&emsp;下面介绍几种常用的寄存器。

**1.通用寄存器**

&emsp;&emsp;8个通用寄存器是8086寄存器的超集，它们分别为：EAX ，EBX ，ECX ，EDX ，EBP ，EBP， ESI及 EDI。这8个通用寄存器中通常保存32位数据，但为了进行16位的操作并与16为机保持兼容，它们的低位部分被当成8个16位的寄存器，即AX、BX…DI。为了支持8位的操作，还进一步把EAX、EBX、ECX、EDX这四个寄存器低位部分的16位，再分为8位一组的高位字节和低位字节两部分，作为8个8位寄存器。这8个寄存器分别被命名为AH、BH、CH、DH和AL、BL、CL、DL。因此，这8个通用寄存器既可以支持1位、8位、16位和32位数据运算，也支持16位和32位存储器寻址。

**2. 段寄存器**

&emsp;&emsp;8086中有4个16位的段寄存器：CS、DS、SS、ES，分别用于存放可执行代码的代码段、数据段、堆栈段和其他段的基地址。在80x86中，有6个16位的段寄存器，但是，这些段寄存器中存放的不再是某个段的基地址，而是某个段的选择符（Selector）。因为16位的寄存器无法存放32位的段基地址，段基地址只好存放在一个叫做描述符表（Descriptor）的表中。因此，在80x86中，我们把段寄存器叫做选择符。有关段选择符、描述符表将在段机制一节进行描述。

**3. 指令指针寄存器和标志寄存器**

&emsp;&emsp;指令指针寄存器EIP中存放下一条将要执行指令的偏移量（offset ），这个偏移量是相对于目前正在运行的代码段寄存器CS而言的。偏移量加上当前代码段的基地址，就形成了下一条指令的地址。EIP中的低16位可以被单独访问，给它起名叫指令指针IP寄存器，用于16位寻址。标志寄存器EFLAGS存放有关处理器的控制标志，很多标志与16位FLAGS中的标志含义一样。 

**4．控制寄存器**

&emsp;&emsp;80x86有四个32位的控制寄存器，它们是CR0，CR1，CR2和CR3，主要用于操作系统的分页机制（参见下节）。其结构如图 2.1所示。

<div align=center>
<img src="2_1.png" />  
</div>

 
&emsp;&emsp;这几个寄存器中保存全局性和任务无关的机器状态。

&emsp;&emsp;CR0中包含了6个预定义标志，这里介绍内核中主要用到的0位和31位。0位是保护允许位PE(Protedted Enable)，用于启动保护模式，如果PE位置1，则保护模式启动，如果PE=0，则在实模式下运行。CR0的第31位是分页允许位(Paging Enable)，它表示芯片上的分页部件是否被允许工作。由PG位和PE位定义的操作方式如图2.2所示。

<div align=center>
<img src="2_2.png" />  
</div>


&emsp;&emsp;使用以下代码就可以允许分页（AT＆T汇编语言参考2.5节）：

    movl %cr0, %eax
    orl  $0x80000000, %eax
    movl %eax, %cr0

&emsp;&emsp;CR1是未定义的控制寄存器，供将来的处理器使用。

&emsp;&emsp;CR2是缺页线性地址寄存器，保存最后一次出现缺页的全32位线性地址（将在内存管理一章介绍）。

&emsp;&emsp;CR3是页目录基址寄存器，保存页目录的物理地址，页目录总是放在以4K字节为单位的存储器边界上，因此，其地址的低12位总为0，不起作用，即使写上内容，也不会被理会。

&emsp;&emsp;这几个寄存器是与分页机制密切相关的，因此，在后面分页机制和第四章虚拟内存管理中会涉及到，读者要记住CR0、CR2及CR3这三个寄存器的作用。 
### **2.1.3 &emsp;物理地址、虚拟地址及线性地址**

&emsp;&emsp;在硬件工程师和普通用户看来，内存就是插在或固化在主板上的内存条，它们有一定的容量，比如128MB。但在应用程序员看来中，并不过度关心插在主板上的内存容量，而是他们可以使用的内存空间，比如，他们可以开发一个占用1 GB内存的程序，并让其在操作系统下运行，哪怕这台机器上只有128 MB的物理内存条。而对于操作系统开发者而言，则是介于二者之间，它既需要知道物理内存的地址，也需要提供一套机制，为应用程序员提供另一个内存空间，这个内存空间的大小可以和实际的物理内存大小之间没有多大关系。

&emsp;&emsp;我们将主板上的物理内存条所提供的内存空间定义为物理内存空间，其中每个内存单元的实际地址就是物理地址；将应用程序员看到的内存空间2定义为虚拟地址空间(或地址空间)，其中的地址就叫虚拟地址(或逻辑地址)， 一般用“段：偏移量”的形式来描述，比如在8086中A815:CF2D就代表段首地址为A815，段内偏移位为CF2D的虚地址。
> 2 因为高级语言不涉及内存空间，因此，这里指的是从汇编语言的角度看。

&emsp;&emsp;线性地址空间是指一段连续的，不分段的，范围为0到4GB的地址空间，一个线性地址就是线性地址空间的一个绝对地址。

&emsp;&emsp;那么，这几种地址之间如何转换？例如，当程序执行“mov  ax，[1024]”这样一条指令时，在8086的实模式下，把某一段寄存器(比如ds)左移4位，然后与16位的偏移量(1024)相加后被直接送到内存总线上，这个相加后的地址就是内存单元的物理地址，而程序中的地址（例如ds:1024）就叫虚拟地址。在80X86保护模式下，这个虚拟地址不是被直接送到内存总线，而是被送到内存管理单元（MMU）。MMU由一个或一组芯片组成，其功能是把虚拟地址映射为物理地址，即进行地址转换，如图2.3所示。

<div align=center>
<img src="2_3.png" />  
</div>


&emsp;&emsp;其中，MMU是一种硬件电路，它包含两个部件，一个是分段部件，一个是分页部件，在本书中，我们把它们分别叫做分段机制和分页机制，以利于从逻辑的角度来理解硬件的实现机制。分段机制把一个虚拟地址转换为线性地址；接着，分页机制把一个线性地址转换为物理地址，如图2.4所示。

<div align=center>
<img src="2_4.png" />  
</div>


&emsp;&emsp;下一节对段机制和分页机制进行具体介绍。
