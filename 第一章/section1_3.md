## **1.3 Linux内核**


&emsp;&emsp;Linux内核指的是在Linus领导下的开发小组开发出的系统内核，它是所有Linux 发布版本的核心。Linux内核软件开发人员一般在百人以上，任何自由程序员都可以提交自己的修改工作，但是只有领导者Linus和Alan Cox才能够将这些工作合并到正式的核心发布版本中。他们一般采用邮件列表来进行项目管理、交流、错误报告。其好处是软件更新速度和发展速度快，计划的开放性好。由于有大量的用户进行测试，而最终裁决人只有少数非常有经验的程序员，因此正式发布的代码质量高。

### **1.3.1 Linux 内核的技术特点**

&emsp;&emsp;Linux是一种是实用性很强的现代操作系统。开发它的中坚力量是经验丰富的软件工程师，他们 多以实用性和效率为出发点，同时还考虑了工业规范和兼容性等因素，因此不同于教学性操作系统单纯追求理论上的先进性，Linux系统内核兼具实用性和高效性。其特色如下：

1) Linux内核被设计成单内核（monolithic）结构，这是相对微内核而言的。所谓单内核就是从整体上把内核作为一个大过程来实现，而进程管理、内存管理等是其中的一个个模块，模块之间可以直接调用相关的函数。微内核是一种功能更贴近硬件的核心软件，它一般仅仅包括基本的内存管理、同步原语、进程间通讯机制、I/O操作和中断管理，这样做有利于提高可扩展性和可移植性。但是微内核与诸如文件管理、设备驱动、虚拟内存管理、进程管理等其它上层模块之间需要有较高的通讯开销，所以目前多集中在理论教学领域，对工业应用来说，效率难以保证 ，因此单内核的Linux效率高，紧凑性强。

2) 2.6版本前的Linux内核是单线程结构——所谓单线程结构是说同一时间只允许有一个执行线程（内核中函数独立执行）在内核中运行 ，不会被调度程序打断而运行其它任务，这种内核称为非抢占式的，它的好处在于内核中没有并发任务（单处理器而言），因此避免了许多复杂的同步问题，但其不利影响是非抢占特性延迟了系统响应速度，新任务必须等待当前任务在内核执行完毕并自动退出后才能获得运行机会。然而，工业控制领域需要高响应速度，由于Robert love等人的贡献，2.6版本将抢占技术引入了Linux内核，使其变为可以进行内核抢占的操作系统 ——当然，付出的代价是同步变得更复杂。

3)Linux内核支持动态加载内核模块。为了保证能方便地支持新设备、新功能，又不会无限地扩大内核规模，Linux系统对设备驱动或新文件系统等采用了模块化的方式，用户在需要时可以现场动态加载，使用完毕可以动态卸载。同时对内核，用户也可以定制，选择适合自己的功能，将不需要的部分剔除出内核。这些都保证了内核的紧凑、可扩展性好。

4) Linux内核被动地提供服务。所谓被动是因为它为用户服务的唯一方式是通过系统调用来请求在内核空间执行某种任务。内核本身是一种函数和数据结构的集合，不存在运行着的内核进程为用户提供服务 

5) Linux内核采用了虚拟内存技术，使得内存空间达到4GB 。其中0-3G属于用户空间，称为用户段，3G-4G属于内核空间，称为内核段。这样，应用程序就可以使用远远大于实际物理内存的存储空间了。

6) Linux的文件系统实现了一种抽象文件模型——虚拟文件系统（Virtual Filesystem Switch,VFS），该文件系统属于Unix风格。VFS是Linux的特色之一。通过使用虚拟文件系统，内核屏蔽了各种不同文件系统的内在差别，使得用户可以通过统一的界面访问各种不同格式的文件系统。

7) Linux提供了一套很有效的延迟执行机制——下半部分、软中断、tasklet和2.6新引入的工作队列等，这些技术保证了系统可以针对任务的轻重缓急，更细粒度地选择执行时机。

&emsp;&emsp;Linux内核的以上特点，在后续的章节中会逐步体现出来。

### **1.3.2 Linux内核的位置**

&emsp;&emsp;Linux内核不是孤立的，必须把它放在整个Linux系统中去研究，图1.2显示了Linux内核在整个系统中的位置：

<div align=center>
<img src="1_2.png" />  
</div>


&emsp;&emsp;由图1.2可以看出，整个系统由四个部分组成：

1.	用户进程—用户应用程序是运行在Linux内核之上的一个庞大的软件集合， 当一个用户程序在操作系统之上运行时，它成为操作系统中的一个进程。关于进程更详细的描述参见第三章。
2.	系统调用接口— 在应用程序中，可通过系统调用来调用操作系统内核中特定的过程，以实现特定的服务。例如，在程序中有一条读取数据的read()系统调用，但是，真正的读取操作是由操作系统内核完成的。所以说，系统调用是内核代码的一部分，更详细内容参看第六章。
3.	Linux内核—内核是操作系统的灵魂，它负责管理内存、磁盘上的文件，负责启动并运行程序，负责从网络上接收和发送数据包等等。内核是本书讨论的重点。
4.	硬件—这个子系统包括了Linux安装时需要的所有可能的物理设备。例如，CPU、 内存、硬盘、网络硬件等等。

### **1.3.3 Linux内核体系结构**

&emsp;&emsp;虽然Linux内核和Unix系统在具体实现上有很大不同，但是其结构还基本保持一致，Linux内核除系统调调用外，由5个主要的子系统组成，如图1.3

<div align=center>
<img src="1_3.png" />  
</div>


1.	**进程调度(Process Scheduler，SCHED)**－控制着进程对CPU的访问。当需要选择一个进程运行时，由调度程序选择最值得运行的进程。
2.	**内存管理(Memory Manager，MM)**－允许多个进程安全地共享主内存区域 。Linux的内存管理支持虚拟内存，即在计算机中运行的程序，其代码、数据和堆栈的总量可以超过实际内存的大小，操作系统只将当前使用的程序块保留在内存中，其余的程序块则保留在磁盘上。必要时，操作系统负责在磁盘和内存之间交换程序块。
因为虚拟内存管理需要硬件支持，因此内存管理从逻辑上可以分为硬件无关的部分和硬件相关的部分。详细内容参看第二章和第四章。
3.	**虚拟文件系统(VFS)**－隐藏各种不同硬件的具体细节，为所有设备提供统一的接口。虚拟文件系统支持多达数十种不同的文件系统，这也是Linux较有特色的一部分。
虚拟文件系统可分为逻辑文件系统和设备驱动程序。逻辑文件系统指Linux所支持的文件系统，如ext2/ext3, ntfs等，设备驱动程序指为每一种硬件控制器所编写的设备驱动程序模块。详细内容参看第八章和第九章。
4.	**网络接口(Network Interface，NET)**－提供了对各种网络标准协议的存取和各种网络硬件的支持。网络子系统可分为网络协议和网络驱动程序两部分。网络协议部分负责实现每一种可能的网络传输协议，网络设备驱动程序负责与硬件设备进行通信，每一种可能的硬件设备都有相应的设备驱动程序。因为这部分内容相对独立和复杂，本书不做详细介绍。
5.	**进程间通信(Inter-Process Communication，IPC)**－ 支持进程间各种通信机制，包括共享内存、消息队列及管道等。这部分内容也相对独立，本书不做详细介绍。

&emsp;&emsp;从图1.3可以看出，处于中心位置的是进程调度，所有其它的子系统都依赖于它，因为每个子系统都需要挂起或恢复进程。一般情况下，当一个进程等待硬件操作完成时，它被挂起；当操作真正完成时，进程恢复执行。例如，当一个进程通过网络发送一条消息时，发送进程被挂起，一直到硬件成功地完成消息的发送。其它子系统(内存管理，虚拟文件系统及进程间通信)以相似的理由依赖于进程调度。

