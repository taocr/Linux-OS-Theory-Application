## 9.1 概述

&emsp;&emsp;Unix操作系统在最初设计的时候就将所有的设备都看成文件，也就是说，把设备纳入文件系统的范畴来管理。Linux操作系统的设计也遵循这一理念。把设备看成文件，具有以下含义：

1.  每个设备都对应一个文件名，在内核中也就对应一个索引节点。应用程序通过设备的文件名寻访具体的设备，而设备则像普通文件一样受到文件系统访问权限控制机制的保护。

2.  对文件操作的系统调用大都适用于设备文件。例如，通过open()系统调用可以打开设备文件，也就是说建立起应用程序与目标设备的连接。之后，就可以通过open()、write()、ioctl()等常规的文件操作对目标设备进行操作。

3.  从应用程序的角度看，设备文件逻辑上的空间是一个线性空间（起始地址为0，每读取一个字节加1）。从这个逻辑空间到具体设备物理空间（如磁盘的磁道、扇区）的映射则是由内核提供，并被划分为文件操作和设备驱动两个层次。

&emsp;&emsp;由此可以看出，对于一个具体的设备而言，文件操作和设备驱动是一个事物的不同层次。从这种观点出发，概念上可以把一个系统划分为应用、文件系统和设备驱动三个层次，如图9.1所示。


<div align=center>
<img src="图9_1.jpg" />  
</div>

<div align=center>
图9.1 设备驱动分层结构示意图
</div>

&emsp;&emsp;Linux将设备分成三大类,就是块设备、字符设备和网络设备。像磁盘那样以块或扇区为单位，成块进行输入／输出的设备，称为 **块设备**，文件系统通常都建立在块设备上；另一类像键盘那样以字符（字节）为单位，逐个字符进行输入／输出的设备，称为 **字符设备**。

&emsp;&emsp;对于不同的设备，其文件系统层的“厚度”有所不同。对于像磁盘这样结构性很强，并且内容需要进一步组织和抽象的设备来说，其文件系统就很“厚重”，这是由磁盘设备的复杂性决定的。一方面是对磁盘物理空间的立体描述，如柱面、磁道、扇区；另一方面是从物理空间到逻辑空间的抽象，如第一层抽象，也就是把柱面、磁头、扇区这样的三维数据转换为一维线性地址空间中的“块”，比如8柱面，9磁头，10扇区对应的块号可能是798。这样操作者就不必关心读／写的物理位置究竟在哪个磁道，哪个扇区。文件系统则是在第一层抽象的基础上进行第二层抽象，即将块抽象和组织为文件系统。它使得操作者不必关心读／写的内容在哪一个逻辑“块”上。于是，我们把第一层抽象归为设备驱动，而把第二层抽象归为文件系统。另一方面，还有一些像字符终端这样的字符设备，其文件系统就比较“薄”，其设备驱动层也比较简单。

&emsp;&emsp;在图9.1中，处于应用层的进程通过文件描述符fd与已打开文件的file结构相联系，每个file结构代表着对一个已打开文件操作的上下文。通过这个上下文，进程就可以对各个文件线性逻辑空间中的数据进行操作。对于普通文件，即磁盘文件，文件的逻辑空间在文件系统层内按具体文件系统的结构和规则映射到设备的线性逻辑空间，然后在设备驱动层进一步从设备的逻辑空间映射到其物理空间。这样一共经历了两次映射。或者，可以反过来说，磁盘设备的物理空间经过两层抽象而成为普通文件的线性逻辑空间。而对于设备文件，则文件的逻辑空间通常直接等价于设备的逻辑空间，所以在文件系统层不需要映射。

&emsp;&emsp;与文件用唯一的索引结点标识相似，一个物理设备也用唯一的索引节点标识，索引节点中记载着与特定设备建立连接所需的信息。这种信息由三部分组成：文件（包括设备）的类型、主设备号和次设备号。其中设备类型和主设备号结合在一起唯一地确定了设备的驱动程序及其接口，而次设备号则说明目标设备是同类设备中的第几个。

&emsp;&emsp;要使一项设备在系统中成为可见、成为应用程序可以访问的设备，首先要在系统中建立一个代表此设备的设备文件，这是通过mknode命令或者mknode()系统调用实现的。除此之外，更重要的是在设备驱动层要有这种设备的驱动程序。

&emsp;&emsp;Linux 驱动在本质上就是一种软件程序，上层软件可以在不用了解硬件特性的情况下，通过驱动提供的接口与计算机硬件进行通信。

&emsp;&emsp;系统调用是内核和应用程序之间的接口，而驱动程序是内核和硬件之间的接口，也就是内核和硬件之间的桥梁。它为应用程序屏蔽了硬件的细节，这样在应用程序看来，硬件设备只是一个设备文件，应用程序可以像操作普通文件一样对硬件设备进行操作。

&emsp;&emsp;那么，系统是如何将设备在用户视野中屏蔽起来的呢？图9.2是对图9.1的进一步抽象，说明了用户进程请求设备进行输入输出的简单流程。

<div align=center>
<img src="图9_2.png" />  
</div>

<div align=center>
图9.2 用户进程请求设备服务的流程
</div>

&emsp;&emsp;首先当用户进程发出输入输出请求时(比如，程序中调用了read()函数)，系统把请求处理的权限放在文件系统（例如进入内核调用文件系统的sys\_read()函数），文件系统通过驱动程序提供的接口(例如驱动程序提供的read()函数)将任务下放到驱动程序，驱动程序根据需要对设备控制器进行操作，设备控制器再去控制设备本身（参见8.2.1节）。

&emsp;&emsp;这样通过层层隔离，对用户进程基本上屏蔽了设备的各种特性，使用户的操作简便易行，不必去考虑具体设备的运作，就像操作文件一样去操作设备。这是因为，在驱动程序向文件系统提供接口时，已经屏蔽掉了设备的电器特性。
